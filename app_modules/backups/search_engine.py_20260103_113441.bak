"""
MODULE: Search Engine System
VERSION: 2.1.0 (TITANIUM)
DESCRIPTION: ÎœÎ·Ï‡Î±Î½Î® Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚ ÏƒÏ„Î± Manuals Ï„Î·Ï‚ Î¼Î½Î®Î¼Î·Ï‚ (Session State).
ENHANCEMENT: Added Speech-to-Text Button.
"""

import streamlit as st
import logging
from typing import List, Dict, Any

# Import Speech-to-Text library with graceful error handling (Rule 1)
try:
    from streamlit_mic_recorder import mic_recorder
except ImportError:
    mic_recorder = None

logger = logging.getLogger("Module_Search")

def _get_badge_color(meta_type: str) -> str:
    """Helper Function: Î•Ï€Î¹ÏƒÏ„ÏÎ­Ï†ÎµÎ¹ Ï‡ÏÏÎ¼Î± Î±Î½Î¬Î»Î¿Î³Î± Î¼Îµ Ï„Î¿Î½ Ï„ÏÏ€Î¿ ÎµÎ³Î³ÏÎ¬Ï†Î¿Ï…."""
    if not meta_type: return "gray"
    meta = meta_type.upper()
    if "ERROR" in meta: return "red"
    if "SERVICE" in meta: return "orange"
    if "USER" in meta: return "green"
    if "INSTALL" in meta: return "blue"
    if "TECHNICAL" in meta: return "violet"
    if "SPARE" in meta: return "yellow"
    if "OTHER" in meta or "GENERAL" in meta or "DOC" in meta: return "gray"
    return "gray"

def render_search_page(library_data: List[Dict[str, Any]]) -> None:
    """
    Î•Î¼Ï†Î±Î½Î¯Î¶ÎµÎ¹ Ï„Î· ÏƒÎµÎ»Î¯Î´Î± Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚.
    Args:
        library_data: Î— Î»Î¯ÏƒÏ„Î± Î¼Îµ Ï„Î± manuals Î±Ï€ÏŒ Ï„Î¿ st.session_state['library_cache']
    """
    st.header("ğŸ” Global Library Search")
    st.caption("Enterprise Indexing System | Google Drive Integration")

    # 1. ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Î”ÎµÎ´Î¿Î¼Î­Î½Ï‰Î½
    if not library_data:
        st.warning("âš ï¸ Î— Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ· ÎµÎ¯Î½Î±Î¹ ÎºÎµÎ½Î®.")
        st.info("Î¤Î¿ ÏƒÏÏƒÏ„Î·Î¼Î± Ï€ÏÎ¿ÏƒÏ€Î±Î¸ÎµÎ¯ Î½Î± ÏƒÏ…Î³Ï‡ÏÎ¿Î½Î¯ÏƒÎµÎ¹... Î‘Î½ ÎµÏ€Î¹Î¼Î­Î½ÎµÎ¹, ÎµÎ¹Î´Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î¿Î½ Admin.")
        return

    # 2. Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬ (Collapsible)
    with st.expander(f"ğŸ“Š Î£Ï„Î±Ï„Î¹ÏƒÏ„Î¹ÎºÎ¬ Î•Ï…ÏÎµÏ„Î·ÏÎ¯Î¿Ï… ({len(library_data)} Î­Î³Î³ÏÎ±Ï†Î±)", expanded=False):
        unique_brands = sorted(list(set(item.get('brand', 'Unknown') for item in library_data if item.get('brand', 'Unknown') != 'UNKNOWN')))
        st.write(f"**ÎœÎ¬ÏÎºÎµÏ‚:** {', '.join(unique_brands[:10])}{'...' if len(unique_brands) > 10 else ''}")
        unique_types = sorted(list(set(item.get('meta_type', 'DOC') for item in library_data if item.get('meta_type', 'DOC') != 'DOC')))
        st.write(f"**Î¤ÏÏ€Î¿Î¹ Î•Î³Î³ÏÎ¬Ï†Ï‰Î½:** {', '.join(unique_types[:10])}{'...' if len(unique_types) > 10 else ''}")
        # Add filtering options if desired in future, e.g., multiselect for brand/type

    # 3. ÎœÏ€Î¬ÏÎ± Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚ Î¼Îµ Î¦Ï‰Î½Î·Ï„Î¹ÎºÎ® Î•Î½Ï„Î¿Î»Î®
    search_col, stt_col = st.columns([8, 1])
    
    current_search_input = st.session_state.get("library_search_input_text", "")

    with search_col:
        query = st.text_input("ğŸ” Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ· (ÎœÎ¬ÏÎºÎ±, ÎœÎ¿Î½Ï„Î­Î»Î¿, ÎšÏ‰Î´Î¹ÎºÏŒÏ‚ Error)...", 
                             placeholder="Ï€.Ï‡. Daikin Altherma J3 Error", 
                             key="library_search_input",
                             value=current_search_input).strip().lower()
        # Update session state for internal use, in case mic_recorder updates it
        st.session_state.library_search_input_text = query
    
    with stt_col:
        st.write("") # Î“Î¹Î± ÎµÏ…Î¸Ï…Î³ÏÎ¬Î¼Î¼Î¹ÏƒÎ·
        st.write("")
        # Rule 1: Microphone/Audio button
        if mic_recorder:
            audio_bytes = mic_recorder(start_prompt="ğŸ¤", stop_prompt="â¹ï¸", key="search_stt_button")
            if audio_bytes:
                st.info("ğŸ§ Audio received. Processing...")
                # Placeholder for actual Speech-to-Text integration
                # In a real application, this would call a STT service
                # For example: text_output = speech_to_text(audio_bytes)
                #              st.session_state.library_search_input_text = text_output
                #              st.rerun() # Re-run to update search input field
        else:
            st.button("ğŸ¤", key="stt_button_placeholder_search")
            st.info("ğŸ§ Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Ï†Ï‰Î½Î·Ï„Î¹ÎºÎ®Ï‚ Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚ Ï…Ï€ÏŒ Î±Î½Î¬Ï€Ï„Ï…Î¾Î·...")


    # 4. Î›Î¿Î³Î¹ÎºÎ® Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ·Ï‚ (AND Logic) - Î¤ÏÏÎ± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î± ÎµÎ¼Ï€Î»Î¿Ï…Ï„Î¹ÏƒÎ¼Î­Î½Î± Î¼ÎµÏ„Î±Î´ÎµÎ´Î¿Î¼Î­Î½Î±
    results = []
    # Use the value from the text input, or from the mic recorder if it updated the state
    search_query_final = st.session_state.get("library_search_input_text", "").strip().lower()

    if search_query_final:
        search_terms = search_query_final.split()
        for item in library_data:
            # Î”Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î± ÎµÎ½ÏŒÏ‚ "Searchable String" Î±Ï€ÏŒ ÏŒÎ»Î± Ï„Î± Ï€ÎµÎ´Î¯Î±
            # Î§ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÎ¼Îµ Ï„Î± Î½Î­Î± Ï€ÎµÎ´Î¯Î±: brand, model, meta_type, error_codes
            full_text = (
                f"{item.get('brand', '')} "
                f"{item.get('model', '')} "
                f"{item.get('meta_type', '')} "
                f"{item.get('name', '')} " # Full path name
                f"{item.get('original_name', '')} " # Original filename
                f"{item.get('error_codes', '')}" # If error codes are added to metadata
            ).lower()
            
            # ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚: ÎŒÎ»Î¿Î¹ Î¿Î¹ ÏŒÏÎ¿Î¹ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± Ï…Ï€Î¬ÏÏ‡Î¿Ï…Î½
            if all(term in full_text for term in search_terms):
                results.append(item)
        logger.info(f"User searched for '{search_query_final}' - Found {len(results)} matches.")
    else:
        # Î‘Î½ Î´ÎµÎ½ Î³ÏÎ¬ÏˆÎµÎ¹ Ï„Î¯Ï€Î¿Ï„Î±, Î´ÎµÎ¯Ï‡Î½Î¿Ï…Î¼Îµ Ï„Î± Ï€ÏÏŒÏƒÏ†Î±Ï„Î± (Î® ÏŒÎ»Î±)
        results = sorted(library_data, key=lambda x: x.get('name', ''), reverse=False) # Sort by name by default
    
    if results:
        for item in results:
            with st.container(border=True):
                col1, col2 = st.columns([4, 1])
                with col1:
                    st.markdown(f"**{item.get('brand', 'N/A')}** - {item.get('model', 'N/A')}")
                    st.markdown(f"*{item.get('original_name', 'N/A')}*")
                    if item.get('error_codes'):
                        st.markdown(f"**Error Codes:** `{item['error_codes']}`")
                with col2:
                    # Badge for meta_type
                    meta_type = item.get('meta_type', 'DOC').replace('_', ' ').title()
                    color = _get_badge_color(item.get('meta_type', 'DOC'))
                    st.markdown(f"###### :{color}[{meta_type}]")
                    st.link_button("ğŸ”— Open PDF", item.get('link', '#'), use_container_width=True)
    else:
        st.info("Î”ÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎ±Î½ Î±Ï€Î¿Ï„ÎµÎ»Î­ÏƒÎ¼Î±Ï„Î± Î³Î¹Î± Ï„Î·Î½ Î±Î½Î±Î¶Î®Ï„Î·ÏƒÎ® ÏƒÎ±Ï‚.")