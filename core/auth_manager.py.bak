import streamlit as st
import bcrypt
from core.db_connector import DatabaseConnector
from datetime import datetime

class AuthManager:
    @staticmethod
    def verify_login(email, password):
        """
        Ελέγχει τα στοιχεία εισόδου.
        Περιλαμβάνει καθαρισμό (trim) για κινητά.
        """
        # 1. ΚΑΘΑΡΙΣΜΟΣ INPUT (Αυτό λύνει το πρόβλημα του κινητού)
        # Σβήνει κενά (space) από την αρχή και το τέλος
        # Μετατρέπει τα κεφαλαία σε μικρά για το email
        if email:
            email = email.strip().lower()
        else:
            return None, "Email required"
            
        if password:
            password = password.strip()
        else:
            return None, "Password required"

        # 2. ΛΗΨΗ ΧΡΗΣΤΩΝ ΑΠΟ ΤΗ ΒΑΣΗ
        users = DatabaseConnector.fetch_data("Users")
        if users.empty: 
            return None, "No users found in database"

        # 3. ΑΝΑΖΗΤΗΣΗ ΧΡΗΣΤΗ
        user = users[users['email'] == email]
        
        if user.empty: 
            return None, "User not found"
        
        user_data = user.iloc[0]
        stored_hash = user_data['password_hash']
        
        # 4. ΕΛΕΓΧΟΣ ΚΩΔΙΚΟΥ
        try:
            # Περίπτωση Α: Παλιός κωδικός (απλό κείμενο - Legacy)
            if not stored_hash.startswith('$2b$'):
                if stored_hash == password:
                    # Αν είναι σωστός, ελέγχουμε αν είναι Active
                    if user_data['role'] == 'active' or user_data['role'] == 'admin':
                        return user_data.to_dict(), "OK"
                    else:
                        return None, "Account Pending Approval"
                else:
                    return None, "Wrong password"
            
            # Περίπτωση Β: Νέος ασφαλής κωδικός (Hash - Bcrypt)
            if bcrypt.checkpw(password.encode('utf-8'), stored_hash.encode('utf-8')):
                # Έλεγχος ρόλου (Active ή Admin)
                if user_data['role'] == 'active' or user_data['role'] == 'admin':
                    return user_data.to_dict(), "OK"
                else:
                    return None, "Account Pending Approval" # Περιμένει έγκριση
            else:
                return None, "Wrong password"
        except Exception as e:
            return None, f"Auth Error: {str(e)}"

    @staticmethod
    def register_new_user(email, name, password):
        """
        Εγγράφει νέο χρήστη ως 'pending'.
        """
        # 1. ΚΑΘΑΡΙΣΜΟΣ INPUT
        if email: email = email.strip().lower()
        if name: name = name.strip()
        if password: password = password.strip()

        if not email or not password:
            return False

        # 2. ΕΛΕΓΧΟΣ ΑΝ ΥΠΑΡΧΕΙ ΗΔΗ
        users = DatabaseConnector.fetch_data("Users")
        if not users.empty and email in users['email'].values:
            return False # Το email υπάρχει ήδη
        
        # 3. ΚΡΥΠΤΟΓΡΑΦΗΣΗ (HASHING)
        hashed = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
        
        # 4. ΔΗΜΙΟΥΡΓΙΑ ΕΓΓΡΑΦΗΣ
        new_user = [
            str(datetime.now()), # Timestamp
            email,
            name,
            hashed,
            "pending" # Role (Μπαίνει ως 'pending' και θέλει έγκριση από Admin)
        ]
        
        return DatabaseConnector.append_data("Users", new_user)

    @staticmethod
    def log_interaction(user_email: str, action: str, description: str):
        """
        Καταγράφει μια αλληλεπίδραση χρήστη στο φύλλο "Logs".
        """
        try:
            log_entry = {
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "user_email": user_email,
                "action": action,
                "description": description
            }
            # Το append_data περιμένει λίστα με τα δεδομένα
            # Θα πρέπει να διασφαλίσουμε ότι το φύλλο "Logs" έχει τις σωστές επικεφαλίδες
            # π.χ., ["timestamp", "user_email", "action", "description"]
            DatabaseConnector.append_data("Logs", list(log_entry.values()))
        except Exception as e:
            st.error(f"Error logging interaction: {e}")